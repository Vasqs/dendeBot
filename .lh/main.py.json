{
  "sourceFile": "main.py",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 108,
      "patches": [
        {
          "date": 1725165410976,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        },
        {
          "date": 1725165837403,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,11 +12,11 @@\n STATS_KEY = os.environ['STATS_KEY']\n API_KEY = os.environ['API_KEY']\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n-commands_url = f'https: //docs.google.com/spreadsheets/d/{\n+commands_url = f'https://docs.google.com/spreadsheets/d/{\n     COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https: //docs.google.com/spreadsheets/d/{\n+stats_url = f'https://docs.google.com/spreadsheets/d/{\n     STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n@@ -48,9 +48,9 @@\n df_commands = fetch_commands()\n stats = fetch_stats()\n \n # URL base para interagir com a API do Telegram\n-base_url = f'https: //api.telegram.org/bot{API_KEY}'\n+base_url = f'https://api.telegram.org/bot{API_KEY}'\n \n \n def read_msg(offset):\n     # Lê mensagens da API do Telegram a partir do offset fornecido\n"
        },
        {
          "date": 1725167121561,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,11 +12,11 @@\n STATS_KEY = os.environ['STATS_KEY']\n API_KEY = os.environ['API_KEY']\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n-commands_url = f'https://docs.google.com/spreadsheets/d/{\n+commandsurl = f'https://docs.google.com/spreadsheets/d/{\n     COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{\n+statsurl = f'https://docs.google.com/spreadsheets/d/{\n     STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n"
        },
        {
          "date": 1725167137218,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,11 +12,11 @@\n STATS_KEY = os.environ['STATS_KEY']\n API_KEY = os.environ['API_KEY']\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n-commandsurl = f'https://docs.google.com/spreadsheets/d/{\n+commands_url = f'https://docs.google.com/spreadsheets/d/{\n     COMMANDS_KEY}/export?gid=0&format=csv'\n-statsurl = f'https://docs.google.com/spreadsheets/d/{\n+stats_url = f'https://docs.google.com/spreadsheets/d/{\n     STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n"
        },
        {
          "date": 1725167612161,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,22 +19,18 @@\n     STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n-    # Faz o download do arquivo CSV da URL fornecida\n     response = requests.get(url)\n-    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n-    # Lê o conteúdo CSV em um DataFrame do pandas\n+    response.raise_for_status()\n     return pd.read_csv(io.StringIO(response.content.decode('utf-8')))\n \n \n def fetch_commands():\n-    # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n \n def fetch_stats():\n-    # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n         'apl_total': stats.iloc[1, 5],\n         'apl_igv': stats.iloc[1, 6],\n@@ -52,9 +48,8 @@\n base_url = f'https://api.telegram.org/bot{API_KEY}'\n \n \n def read_msg(offset):\n-    # Lê mensagens da API do Telegram a partir do offset fornecido\n     parameters = {\"offset\": offset}\n     resp = requests.get(f'{base_url}/getUpdates', params=parameters)\n     resp.raise_for_status()\n     data = resp.json()\n@@ -67,9 +62,8 @@\n     return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n \n \n def auto_answer(message):\n-    # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith('/'):\n         return None\n \n     # Remove o nome de usuário se presente\n@@ -88,9 +82,8 @@\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n \n def send_msg(message):\n-    # Envia uma mensagem de volta ao usuário no Telegram\n     try:\n         if \"message\" in message:\n             msg = message[\"message\"]\n             if \"text\" in msg:\n"
        },
        {
          "date": 1725167663459,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,18 +19,22 @@\n     STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n+    # Faz o download do arquivo CSV da URL fornecida\n     response = requests.get(url)\n-    response.raise_for_status()\n+    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n+    # Lê o conteúdo CSV em um DataFrame do pandas\n     return pd.read_csv(io.StringIO(response.content.decode('utf-8')))\n \n \n def fetch_commands():\n+    # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n \n def fetch_stats():\n+    # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n         'apl_total': stats.iloc[1, 5],\n         'apl_igv': stats.iloc[1, 6],\n@@ -48,8 +52,9 @@\n base_url = f'https://api.telegram.org/bot{API_KEY}'\n \n \n def read_msg(offset):\n+    # Lê mensagens da API do Telegram a partir do offset fornecido\n     parameters = {\"offset\": offset}\n     resp = requests.get(f'{base_url}/getUpdates', params=parameters)\n     resp.raise_for_status()\n     data = resp.json()\n@@ -62,8 +67,9 @@\n     return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n \n \n def auto_answer(message):\n+    # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith('/'):\n         return None\n \n     # Remove o nome de usuário se presente\n@@ -82,8 +88,9 @@\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n \n def send_msg(message):\n+    # Envia uma mensagem de volta ao usuário no Telegram\n     try:\n         if \"message\" in message:\n             msg = message[\"message\"]\n             if \"text\" in msg:\n"
        },
        {
          "date": 1725167923404,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,10 @@\n import requests\n import pandas as pd\n import io\n from keep_alive import keep_alive\n+from dotenv import load_dotenv\n+load_dotenv()\n \n # Mantém o bot ativo na web\n keep_alive()\n \n"
        },
        {
          "date": 1725298521911,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,33 +1,32 @@\n import os\n+import io\n import requests\n import pandas as pd\n-import io\n+from dotenv import load_dotenv\n from keep_alive import keep_alive\n-from dotenv import load_dotenv\n+\n load_dotenv()\n \n # Mantém o bot ativo na web\n keep_alive()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n-COMMANDS_KEY = os.environ['COMMANDS_KEY']\n-STATS_KEY = os.environ['STATS_KEY']\n-API_KEY = os.environ['API_KEY']\n+COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n+STATS_KEY = os.environ[\"STATS_KEY\"]\n+API_KEY = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n-commands_url = f'https://docs.google.com/spreadsheets/d/{\n-    COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{\n-    STATS_KEY}/export?gid=1076143484&format=csv'\n+commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n+stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n-    response = requests.get(url)\n+    response = requests.get(url, timeout=10)\n     response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n     # Lê o conteúdo CSV em um DataFrame do pandas\n-    return pd.read_csv(io.StringIO(response.content.decode('utf-8')))\n+    return pd.read_csv(io.StringIO(response.content.decode(\"utf-8\")))\n \n \n def fetch_commands():\n     # Obtém o DataFrame contendo os comandos\n@@ -37,28 +36,28 @@\n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n-        'apl_total': stats.iloc[1, 5],\n-        'apl_igv': stats.iloc[1, 6],\n-        'apl_ogv': stats.iloc[1, 9],\n-        'apl_ogta': stats.iloc[1, 10],\n-        'apl_ogte': stats.iloc[1, 11]\n+        \"apl_total\": stats.iloc[1, 5],\n+        \"apl_igv\": stats.iloc[1, 6],\n+        \"apl_ogv\": stats.iloc[1, 9],\n+        \"apl_ogta\": stats.iloc[1, 10],\n+        \"apl_ogte\": stats.iloc[1, 11],\n     }\n \n \n # Obtém os dados iniciais das planilhas\n df_commands = fetch_commands()\n stats = fetch_stats()\n \n # URL base para interagir com a API do Telegram\n-base_url = f'https://api.telegram.org/bot{API_KEY}'\n+base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n \n \n def read_msg(offset):\n     # Lê mensagens da API do Telegram a partir do offset fornecido\n     parameters = {\"offset\": offset}\n-    resp = requests.get(f'{base_url}/getUpdates', params=parameters)\n+    resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n     resp.raise_for_status()\n     data = resp.json()\n \n     # Envia cada mensagem recebida\n@@ -70,22 +69,21 @@\n \n \n def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n-    if not message.startswith('/'):\n+    if not message.startswith(\"/\"):\n         return None\n \n     # Remove o nome de usuário se presente\n-    message = message.split('@')[0] if '@' in message else message\n+    message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc[df_commands['Question'].str.lower(\n-    ) == message.lower()]\n+    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n \n     if not answer_row.empty:\n-        answer = answer_row.iloc[0]['Answer']\n+        answer = answer_row.iloc[0][\"Answer\"]\n         for key, value in stats.items():\n-            answer = answer.replace(f'{{{key}}}', value)\n+            answer = answer.replace(f\"{{{key}}}\", value)\n         return answer\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n@@ -103,28 +101,35 @@\n \n                 parameters = {\n                     \"chat_id\": chat_id,\n                     # Garante o encoding correto\n-                    \"text\": answer.encode('utf-8').decode('utf-8'),\n-                    \"reply_to_message_id\": message_id\n+                    \"text\": answer.encode(\"utf-8\").decode(\"utf-8\"),\n+                    \"reply_to_message_id\": message_id,\n                 }\n                 resp = requests.get(\n-                    f'{base_url}/sendMessage', params=parameters)\n+                    f\"{base_url}/sendMessage\", params=parameters, timeout=10\n+                )\n                 resp.raise_for_status()\n-                print(resp.text)\n+                print(\"Message received\")\n             else:\n-                print(\"Mensagem sem texto:\", msg)\n+                print(\"Mensagem with no text:\", msg)\n         else:\n-            print(\"Mensagem não encontrada:\", message)\n+            print(\"Mensagem not found:\", message)\n+    except requests.exceptions.Timeout:\n+        print(\"Timeout error occurred\")\n+    except requests.exceptions.ConnectionError:\n+        print(\"Connection error occurred\")\n     except requests.exceptions.HTTPError as http_err:\n         if resp.status_code == 400:\n-            print(\"Erro 400: Ignorando mensagem excluída\")\n+            print(\"Erro 400: Ignoring deleted message\")\n         else:\n             print(f\"HTTP error occurred: {http_err}\")\n+    except requests.exceptions.RequestException as req_err:\n+        print(f\"Request error occurred: {req_err}\")\n     except Exception as err:\n-        print(f\"Other error occurred: {err}\")\n+        print(f\"An unexpected error occurred: {err}\")\n \n \n # Loop principal para ler mensagens continuamente\n offset = 0\n while True:\n-    offset = read_msg(offset)\n+    offset = read_msg(offset)\n\\ No newline at end of file\n"
        },
        {
          "date": 1725299708753,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,14 @@\n+# bot.py\n+\n import os\n import io\n import requests\n import pandas as pd\n from dotenv import load_dotenv\n-from keep_alive import keep_alive\n \n load_dotenv()\n \n-# Mantém o bot ativo na web\n-keep_alive()\n-\n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n API_KEY = os.environ[\"API_KEY\"]\n@@ -18,22 +16,19 @@\n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n \n-\n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n     response = requests.get(url, timeout=10)\n     response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n     # Lê o conteúdo CSV em um DataFrame do pandas\n     return pd.read_csv(io.StringIO(response.content.decode(\"utf-8\")))\n \n-\n def fetch_commands():\n     # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n-\n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n@@ -43,40 +38,19 @@\n         \"apl_ogta\": stats.iloc[1, 10],\n         \"apl_ogte\": stats.iloc[1, 11],\n     }\n \n-\n-# Obtém os dados iniciais das planilhas\n-df_commands = fetch_commands()\n-stats = fetch_stats()\n-\n-# URL base para interagir com a API do Telegram\n-base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n-\n-\n-def read_msg(offset):\n-    # Lê mensagens da API do Telegram a partir do offset fornecido\n-    parameters = {\"offset\": offset}\n-    resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n-    resp.raise_for_status()\n-    data = resp.json()\n-\n-    # Envia cada mensagem recebida\n-    for result in data[\"result\"]:\n-        send_msg(result)\n-\n-    # Atualiza o offset para evitar processar mensagens duplicadas\n-    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n-\n-\n def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith(\"/\"):\n         return None\n \n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n+    df_commands = fetch_commands()\n+    stats = fetch_stats()\n+\n     # Busca pela resposta correspondente ao comando\n     answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n \n     if not answer_row.empty:\n@@ -84,52 +58,5 @@\n         for key, value in stats.items():\n             answer = answer.replace(f\"{{{key}}}\", value)\n         return answer\n     else:\n-        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n-\n-\n-def send_msg(message):\n-    # Envia uma mensagem de volta ao usuário no Telegram\n-    try:\n-        if \"message\" in message:\n-            msg = message[\"message\"]\n-            if \"text\" in msg:\n-                text = msg[\"text\"]\n-                message_id = msg[\"message_id\"]\n-                chat_id = msg[\"chat\"][\"id\"]\n-                answer = auto_answer(text)  # Obtém a resposta automática\n-\n-                parameters = {\n-                    \"chat_id\": chat_id,\n-                    # Garante o encoding correto\n-                    \"text\": answer.encode(\"utf-8\").decode(\"utf-8\"),\n-                    \"reply_to_message_id\": message_id,\n-                }\n-                resp = requests.get(\n-                    f\"{base_url}/sendMessage\", params=parameters, timeout=10\n-                )\n-                resp.raise_for_status()\n-                print(\"Message received\")\n-            else:\n-                print(\"Mensagem with no text:\", msg)\n-        else:\n-            print(\"Mensagem not found:\", message)\n-    except requests.exceptions.Timeout:\n-        print(\"Timeout error occurred\")\n-    except requests.exceptions.ConnectionError:\n-        print(\"Connection error occurred\")\n-    except requests.exceptions.HTTPError as http_err:\n-        if resp.status_code == 400:\n-            print(\"Erro 400: Ignoring deleted message\")\n-        else:\n-            print(f\"HTTP error occurred: {http_err}\")\n-    except requests.exceptions.RequestException as req_err:\n-        print(f\"Request error occurred: {req_err}\")\n-    except Exception as err:\n-        print(f\"An unexpected error occurred: {err}\")\n-\n-\n-# Loop principal para ler mensagens continuamente\n-offset = 0\n-while True:\n-    offset = read_msg(offset)\n\\ No newline at end of file\n+        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n\\ No newline at end of file\n"
        },
        {
          "date": 1725299719364,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-# bot.py\n-\n import os\n import io\n import requests\n import pandas as pd\n"
        },
        {
          "date": 1725300395543,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n import io\n import requests\n import pandas as pd\n from dotenv import load_dotenv\n+from telegram.ext import Updater, CommandHandler, MessageHandler\n \n load_dotenv()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n@@ -36,12 +37,13 @@\n         \"apl_ogta\": stats.iloc[1, 10],\n         \"apl_ogte\": stats.iloc[1, 11],\n     }\n \n-def auto_answer(message):\n+def auto_answer(update, context):\n     # Gera uma resposta automática para a mensagem recebida\n+    message = update.message.text\n     if not message.startswith(\"/\"):\n-        return None\n+        return\n \n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n@@ -54,7 +56,21 @@\n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         for key, value in stats.items():\n             answer = answer.replace(f\"{{{key}}}\", value)\n-        return answer\n+        context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n     else:\n\\ No newline at end of file\n-        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n+        context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n+\n+def main():\n+    updater = Updater(API_KEY, use_context=True)\n+\n+    dp = updater.dispatcher\n+\n+    dp.add_handler(CommandHandler(\"start\", auto_answer))\n+    dp.add_handler(MessageHandler(None, auto_answer))\n+\n+    updater.start_polling()\n+    updater.idle()\n+\n+if __name__ == \"__main__\":\n+    main()\n\\ No newline at end of file\n"
        },
        {
          "date": 1725300559534,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n     else:\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n def main():\n-    updater = Updater(API_KEY, use_context=True)\n+    updater = Updater(API_KEY)\n \n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n"
        },
        {
          "date": 1725300613226,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,12 @@\n import requests\n import pandas as pd\n from dotenv import load_dotenv\n from telegram.ext import Updater, CommandHandler, MessageHandler\n+from queue import Queue\n \n+\n+\n load_dotenv()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n@@ -62,8 +65,10 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n def main():\n     updater = Updater(API_KEY)\n+    update_queue = Queue()\n+    updater = Updater(TELEGRAM_TOKEN, update_queue)\n \n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n"
        },
        {
          "date": 1725300631726,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,13 +63,15 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n     else:\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n+update_queue = Queue()\n+updater = Updater(TELEGRAM_TOKEN, update_queue)\n+\n def main():\n     updater = Updater(API_KEY)\n-    update_queue = Queue()\n-    updater = Updater(TELEGRAM_TOKEN, update_queue)\n \n+\n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n"
        },
        {
          "date": 1725300651358,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,15 +63,13 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n     else:\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n-update_queue = Queue()\n-updater = Updater(TELEGRAM_TOKEN, update_queue)\n-\n def main():\n     updater = Updater(API_KEY)\n+    update_queue = Queue()\n+    updater = Updater(API_KEY, update_queue)\n \n-\n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n"
        },
        {
          "date": 1725300664248,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,12 +63,12 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n     else:\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n+update_queue = Queue()\n+updater = Updater(API_KEY, update_queue)\n def main():\n     updater = Updater(API_KEY)\n-    update_queue = Queue()\n-    updater = Updater(API_KEY, update_queue)\n \n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n"
        },
        {
          "date": 1725300675177,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,13 +63,13 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n     else:\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n-update_queue = Queue()\n-updater = Updater(API_KEY, update_queue)\n+\n def main():\n     updater = Updater(API_KEY)\n-\n+    update_queue = Queue()\n+    updater = Updater(API_KEY, update_queue)\n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n"
        },
        {
          "date": 1725300682350,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,8 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n \n def main():\n-    updater = Updater(API_KEY)\n     update_queue = Queue()\n     updater = Updater(API_KEY, update_queue)\n     dp = updater.dispatcher\n \n"
        },
        {
          "date": 1725300744395,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,11 @@\n import pandas as pd\n from dotenv import load_dotenv\n from telegram.ext import Updater, CommandHandler, MessageHandler\n from queue import Queue\n+from telegram.ext import Dispatcher\n \n \n-\n load_dotenv()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n@@ -67,8 +67,9 @@\n \n def main():\n     update_queue = Queue()\n     updater = Updater(API_KEY, update_queue)\n+    dispatcher = updater.dispatcher\n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n"
        },
        {
          "date": 1725300757584,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,10 +67,10 @@\n \n def main():\n     update_queue = Queue()\n     updater = Updater(API_KEY, update_queue)\n+    dp = updater.dispatcher\n     dispatcher = updater.dispatcher\n-    dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n \n"
        },
        {
          "date": 1725300769198,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import pandas as pd\n from dotenv import load_dotenv\n from telegram.ext import Updater, CommandHandler, MessageHandler\n from queue import Queue\n-from telegram.ext import Dispatcher\n+from telegram.ext import Dispatcher as dp\n \n \n load_dotenv()\n \n"
        },
        {
          "date": 1725300775438,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,11 +67,10 @@\n \n def main():\n     update_queue = Queue()\n     updater = Updater(API_KEY, update_queue)\n-    dp = updater.dispatcher\n-    dispatcher = updater.dispatcher\n \n+\n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n \n     updater.start_polling()\n"
        },
        {
          "date": 1725300785273,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,11 @@\n import pandas as pd\n from dotenv import load_dotenv\n from telegram.ext import Updater, CommandHandler, MessageHandler\n from queue import Queue\n-from telegram.ext import Dispatcher as dp\n \n \n+\n load_dotenv()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n@@ -67,10 +67,10 @@\n \n def main():\n     update_queue = Queue()\n     updater = Updater(API_KEY, update_queue)\n+    dp = updater.dispatcher\n \n-\n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n \n     updater.start_polling()\n"
        },
        {
          "date": 1725300848857,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,18 +3,15 @@\n import requests\n import pandas as pd\n from dotenv import load_dotenv\n from telegram.ext import Updater, CommandHandler, MessageHandler\n-from queue import Queue\n \n-\n-\n load_dotenv()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n-API_KEY = os.environ[\"API_KEY\"]\n+TELEGRAM_TOKEN = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n@@ -63,12 +60,11 @@\n         context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n     else:\n         context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n \n+def main():\n+    updater = Updater(TELEGRAM_TOKEN, use_context=True)\n \n-def main():\n-    update_queue = Queue()\n-    updater = Updater(API_KEY, update_queue)\n     dp = updater.dispatcher\n \n     dp.add_handler(CommandHandler(\"start\", auto_answer))\n     dp.add_handler(MessageHandler(None, auto_answer))\n"
        },
        {
          "date": 1725300868176,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,10 @@\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n-TELEGRAM_TOKEN = os.environ[\"API_KEY\"]\n+API_KEY = os.environ[\"API_KEY\"]\n+TELEGRAM_TOKEN = os.environ[\"TELEGRAM_TOKEN\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n"
        },
        {
          "date": 1725300888927,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n API_KEY = os.environ[\"API_KEY\"]\n-TELEGRAM_TOKEN = os.environ[\"TELEGRAM_TOKEN\"]\n+TELEGRAM_TOKEN = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n"
        },
        {
          "date": 1725300899377,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,17 +2,15 @@\n import io\n import requests\n import pandas as pd\n from dotenv import load_dotenv\n-from telegram.ext import Updater, CommandHandler, MessageHandler\n \n load_dotenv()\n \n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n API_KEY = os.environ[\"API_KEY\"]\n-TELEGRAM_TOKEN = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n@@ -38,13 +36,12 @@\n         \"apl_ogta\": stats.iloc[1, 10],\n         \"apl_ogte\": stats.iloc[1, 11],\n     }\n \n-def auto_answer(update, context):\n+def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n-    message = update.message.text\n     if not message.startswith(\"/\"):\n-        return\n+        return None\n \n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n@@ -57,21 +54,7 @@\n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         for key, value in stats.items():\n             answer = answer.replace(f\"{{{key}}}\", value)\n-        context.bot.send_message(chat_id=update.effective_chat.id, text=answer)\n+        return answer\n     else:\n-        context.bot.send_message(chat_id=update.effective_chat.id, text=\"Não sei esse comando não pvt, manda Ananda me programar melhor aê\")\n-\n-def main():\n-    updater = Updater(TELEGRAM_TOKEN, use_context=True)\n-\n-    dp = updater.dispatcher\n-\n-    dp.add_handler(CommandHandler(\"start\", auto_answer))\n-    dp.add_handler(MessageHandler(None, auto_answer))\n-\n-    updater.start_polling()\n-    updater.idle()\n-\n-if __name__ == \"__main__\":\n\\ No newline at end of file\n-    main()\n+        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n\\ No newline at end of file\n"
        },
        {
          "date": 1725304132997,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,11 +2,15 @@\n import io\n import requests\n import pandas as pd\n from dotenv import load_dotenv\n+from keep_alive import keep_alive\n \n load_dotenv()\n \n+# Mantém o bot ativo na web\n+keep_alive()\n+\n # Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n API_KEY = os.environ[\"API_KEY\"]\n@@ -14,19 +18,22 @@\n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n \n+\n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n     response = requests.get(url, timeout=10)\n     response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n     # Lê o conteúdo CSV em um DataFrame do pandas\n     return pd.read_csv(io.StringIO(response.content.decode(\"utf-8\")))\n \n+\n def fetch_commands():\n     # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n+\n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n@@ -36,19 +43,40 @@\n         \"apl_ogta\": stats.iloc[1, 10],\n         \"apl_ogte\": stats.iloc[1, 11],\n     }\n \n+\n+# Obtém os dados iniciais das planilhas\n+df_commands = fetch_commands()\n+stats = fetch_stats()\n+\n+# URL base para interagir com a API do Telegram\n+base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n+\n+\n+def read_msg(offset):\n+    # Lê mensagens da API do Telegram a partir do offset fornecido\n+    parameters = {\"offset\": offset}\n+    resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n+    resp.raise_for_status()\n+    data = resp.json()\n+\n+    # Envia cada mensagem recebida\n+    for result in data[\"result\"]:\n+        send_msg(result)\n+\n+    # Atualiza o offset para evitar processar mensagens duplicadas\n+    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n+\n+\n def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith(\"/\"):\n         return None\n \n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n-    df_commands = fetch_commands()\n-    stats = fetch_stats()\n-\n     # Busca pela resposta correspondente ao comando\n     answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n \n     if not answer_row.empty:\n@@ -56,5 +84,52 @@\n         for key, value in stats.items():\n             answer = answer.replace(f\"{{{key}}}\", value)\n         return answer\n     else:\n-        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n\\ No newline at end of file\n+        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n+\n+\n+def send_msg(message):\n+    # Envia uma mensagem de volta ao usuário no Telegram\n+    try:\n+        if \"message\" in message:\n+            msg = message[\"message\"]\n+            if \"text\" in msg:\n+                text = msg[\"text\"]\n+                message_id = msg[\"message_id\"]\n+                chat_id = msg[\"chat\"][\"id\"]\n+                answer = auto_answer(text)  # Obtém a resposta automática\n+\n+                parameters = {\n+                    \"chat_id\": chat_id,\n+                    # Garante o encoding correto\n+                    \"text\": answer.encode(\"utf-8\").decode(\"utf-8\"),\n+                    \"reply_to_message_id\": message_id,\n+                }\n+                resp = requests.get(\n+                    f\"{base_url}/sendMessage\", params=parameters, timeout=10\n+                )\n+                resp.raise_for_status()\n+                print(\"Message received\")\n+            else:\n+                print(\"Mensagem with no text:\", msg)\n+        else:\n+            print(\"Mensagem not found:\", message)\n+    except requests.exceptions.Timeout:\n+        print(\"Timeout error occurred\")\n+    except requests.exceptions.ConnectionError:\n+        print(\"Connection error occurred\")\n+    except requests.exceptions.HTTPError as http_err:\n+        if resp.status_code == 400:\n+            print(\"Erro 400: Ignoring deleted message\")\n+        else:\n+            print(f\"HTTP error occurred: {http_err}\")\n+    except requests.exceptions.RequestException as req_err:\n+        print(f\"Request error occurred: {req_err}\")\n+    except Exception as err:\n+        print(f\"An unexpected error occurred: {err}\")\n+\n+\n+# Loop principal para ler mensagens continuamente\n+offset = 0\n+while True:\n+    offset = read_msg(offset)\n\\ No newline at end of file\n"
        },
        {
          "date": 1725304601923,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n API_KEY = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n+stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={stats_gid}&format=csv'\n \n \n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n@@ -35,8 +35,9 @@\n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n+    stats_gid = \"1076143484\"\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725304981611,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n API_KEY = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={stats_gid}&format=csv'\n+stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n \n \n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n@@ -35,9 +35,8 @@\n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n-    stats_gid = \"1076143484\"\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305006775,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n API_KEY = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid=1076143484&format=csv'\n+stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={stats_gid}&format=csv'\n \n \n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n@@ -35,8 +35,9 @@\n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n+    stats_gid = \"1076143484\"\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305055405,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,10 +35,10 @@\n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n-    stats_gid = \"1076143484\"\n     return {\n+        stats_gid = \"1076143484\"\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n         \"apl_ogta\": stats.iloc[1, 10],\n"
        },
        {
          "date": 1725305068429,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n-        stats_gid = \"1076143484\"\n+        stats_gid: \"1076143484\"\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n         \"apl_ogta\": stats.iloc[1, 10],\n"
        },
        {
          "date": 1725305075068,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n     return {\n-        stats_gid: \"1076143484\"\n+        stats_gid: \"1076143484\",\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n         \"apl_ogta\": stats.iloc[1, 10],\n"
        },
        {
          "date": 1725305094268,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,10 +35,10 @@\n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats = fetch_csv(stats_url)\n+    stats_gid = \"1076143484\"\n     return {\n-        stats_gid: \"1076143484\",\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n         \"apl_ogta\": stats.iloc[1, 10],\n"
        },
        {
          "date": 1725305102459,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,10 +34,10 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n+    stats_gid = \"1076143484\"\n     stats = fetch_csv(stats_url)\n-    stats_gid = \"1076143484\"\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305145072,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = \"1076143484\"\n+    stats_gid = '1076143484',\n     stats = fetch_csv(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n"
        },
        {
          "date": 1725305182574,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = '1076143484',\n+    stats_gid = 1076143484,\n     stats = fetch_csv(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n"
        },
        {
          "date": 1725305259423,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,10 +34,11 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = 1076143484,\n+    stats_gid = '1076143484',\n     stats = fetch_csv(stats_url)\n+    print(\"1\".format(stats_gid))\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305275071,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n     stats_gid = '1076143484',\n     stats = fetch_csv(stats_url)\n-    print(\"1\".format(stats_gid))\n+    print(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305335904,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,11 +34,10 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = '1076143484',\n+    stats_gid = {\"stats_gid\":1076143484}\n     stats = fetch_csv(stats_url)\n-    print(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305371008,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = {\"stats_gid\":1076143484}\n+    parameters = {\"stats_gid\":1076143484}\n     stats = fetch_csv(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n"
        },
        {
          "date": 1725305399722,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    parameters = {\"stats_gid\":1076143484}\n+    parameters = {\"stats_gid\":'1076143484'}\n     stats = fetch_csv(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n"
        },
        {
          "date": 1725305438335,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,10 +34,11 @@\n \n \n def fetch_stats():\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    parameters = {\"stats_gid\":'1076143484'}\n+\n     stats = fetch_csv(stats_url)\n+        parameters = {\"stats_gid\":'1076143484'}\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305691424,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,13 +32,12 @@\n     # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n \n-def fetch_stats():\n+def fetch_stats(stats_gid):\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-\n+    stats_gid = {\"stats_gid\":1076143484}\n     stats = fetch_csv(stats_url)\n-        parameters = {\"stats_gid\":'1076143484'}\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n         \"apl_ogv\": stats.iloc[1, 9],\n"
        },
        {
          "date": 1725305707540,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \n \n def fetch_stats(stats_gid):\n     # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = {\"stats_gid\":1076143484}\n+    stats_gid = 1076143484\n     stats = fetch_csv(stats_url)\n     return {\n         \"apl_total\": stats.iloc[1, 5],\n         \"apl_igv\": stats.iloc[1, 6],\n"
        },
        {
          "date": 1725306202855,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n API_KEY = os.environ[\"API_KEY\"]\n \n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={stats_gid}&format=csv'\n+stats_url_template = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={{gid}}&format=csv'\n \n \n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n@@ -32,25 +32,37 @@\n     # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n \n-def fetch_stats(stats_gid):\n-    # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats_gid = 1076143484\n+def fetch_stats(gid):\n+    # Obtém o DataFrame contendo as estatísticas da página especificada e retorna um dicionário com valores específicos\n+    stats_url = stats_url_template.format(gid=gid)\n     stats = fetch_csv(stats_url)\n     return {\n-        \"apl_total\": stats.iloc[1, 5],\n-        \"apl_igv\": stats.iloc[1, 6],\n-        \"apl_ogv\": stats.iloc[1, 9],\n-        \"apl_ogta\": stats.iloc[1, 10],\n-        \"apl_ogte\": stats.iloc[1, 11],\n+        \"total\": stats.iloc[1, 5],\n+        \"igv\": stats.iloc[1, 6],\n+        \"ogv\": stats.iloc[1, 9],\n+        \"ogta\": stats.iloc[1, 10],\n+        \"ogte\": stats.iloc[1, 11]\n     }\n \n \n # Obtém os dados iniciais das planilhas\n df_commands = fetch_commands()\n-stats = fetch_stats()\n+stats_apl = fetch_stats(1076143484)\n+stats_apd = fetch_stats(1226391324)\n \n+# Combine os dados das duas páginas conforme necessário\n+combined_stats = {\n+    \"apl_total\": stats_apl[\"total\"],\n+    \"apl_igv\": stats_apl[\"igv\"],\n+    \"apl_ogv\": stats_apl[\"ogv\"],\n+    \"apl_ogta\": stats_apl[\"ogta\"],\n+    \"apl_ogte\": stats_apl[\"ogte\"],\n+    \"apd_plan\": stats_apd[\"total\"],\n+    \"apd_done\": stats_apd[\"igv\"]\n+}\n+\n # URL base para interagir com a API do Telegram\n base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n \n \n@@ -81,10 +93,10 @@\n     answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n-        for key, value in stats.items():\n-            answer = answer.replace(f\"{{{key}}}\", value)\n+        for key, value in combined_stats.items():\n+            answer = answer.replace(f\"{{{key}}}\", str(value))\n         return answer\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n@@ -132,5 +144,5 @@\n \n # Loop principal para ler mensagens continuamente\n offset = 0\n while True:\n-    offset = read_msg(offset)\n\\ No newline at end of file\n+    offset = read_msg(offset)\n"
        },
        {
          "date": 1725306351886,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n     # Obtém o DataFrame contendo as estatísticas da página especificada e retorna um dicionário com valores específicos\n     stats_url = stats_url_template.format(gid=gid)\n     stats = fetch_csv(stats_url)\n     return {\n-        \"total\": stats.iloc[1, 5],\n+        \"total\": stats.iloc[3, 5],\n         \"igv\": stats.iloc[1, 6],\n         \"ogv\": stats.iloc[1, 9],\n         \"ogta\": stats.iloc[1, 10],\n         \"ogte\": stats.iloc[1, 11]\n@@ -58,9 +58,9 @@\n     \"apl_ogv\": stats_apl[\"ogv\"],\n     \"apl_ogta\": stats_apl[\"ogta\"],\n     \"apl_ogte\": stats_apl[\"ogte\"],\n     \"apd_plan\": stats_apd[\"total\"],\n-    \"apd_done\": stats_apd[\"igv\"]\n+    \"apd_done\": stats_apd[\"done\"]\n }\n \n # URL base para interagir com a API do Telegram\n base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n"
        },
        {
          "date": 1725306428094,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,10 @@\n         \"total\": stats.iloc[3, 5],\n         \"igv\": stats.iloc[1, 6],\n         \"ogv\": stats.iloc[1, 9],\n         \"ogta\": stats.iloc[1, 10],\n-        \"ogte\": stats.iloc[1, 11]\n+        \"ogte\": stats.iloc[1, 11],\n+        \"done\": stats.iloc[3,5]\n     }\n \n \n # Obtém os dados iniciais das planilhas\n"
        },
        {
          "date": 1725306773614,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,35 +32,43 @@\n     # Obtém o DataFrame contendo os comandos\n     return fetch_csv(commands_url)\n \n \n-def fetch_stats(gid):\n-    # Obtém o DataFrame contendo as estatísticas da página especificada e retorna um dicionário com valores específicos\n+def fetch_stats(gid, type_):\n+    # Obtém o DataFrame contendo as estatísticas da página especificada\n     stats_url = stats_url_template.format(gid=gid)\n     stats = fetch_csv(stats_url)\n-    return {\n-        \"total\": stats.iloc[3, 5],\n-        \"igv\": stats.iloc[1, 6],\n-        \"ogv\": stats.iloc[1, 9],\n-        \"ogta\": stats.iloc[1, 10],\n-        \"ogte\": stats.iloc[1, 11],\n-        \"done\": stats.iloc[3,5]\n-    }\n+    \n+    if type_ == \"APL\":\n+        return {\n+            \"total\": stats.iloc[1, 5],\n+            \"igv\": stats.iloc[1, 6],\n+            \"ogv\": stats.iloc[1, 9],\n+            \"ogta\": stats.iloc[1, 10],\n+            \"ogte\": stats.iloc[1, 11]\n+        }\n+    elif type_ == \"APD\":\n+        return {\n+            \"plan\": stats.iloc[3, 8],\n+            \"done\": stats.iloc[3, 9]\n+        }\n+    else:\n+        raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n \n \n # Obtém os dados iniciais das planilhas\n df_commands = fetch_commands()\n-stats_apl = fetch_stats(1076143484)\n-stats_apd = fetch_stats(1226391324)\n+stats_apl = fetch_stats(1076143484, \"APL\")\n+stats_apd = fetch_stats(1226391324, \"APD\")\n \n # Combine os dados das duas páginas conforme necessário\n combined_stats = {\n     \"apl_total\": stats_apl[\"total\"],\n     \"apl_igv\": stats_apl[\"igv\"],\n     \"apl_ogv\": stats_apl[\"ogv\"],\n     \"apl_ogta\": stats_apl[\"ogta\"],\n     \"apl_ogte\": stats_apl[\"ogte\"],\n-    \"apd_plan\": stats_apd[\"total\"],\n+    \"apd_plan\": stats_apd[\"plan\"],\n     \"apd_done\": stats_apd[\"done\"]\n }\n \n # URL base para interagir com a API do Telegram\n"
        },
        {
          "date": 1725306828177,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n             \"ogte\": stats.iloc[1, 11]\n         }\n     elif type_ == \"APD\":\n         return {\n-            \"plan\": stats.iloc[3, 8],\n-            \"done\": stats.iloc[3, 9]\n+            \"plan\": stats.iloc[2, 8],\n+            \"done\": stats.iloc[2, 9]\n         }\n     else:\n         raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n \n"
        },
        {
          "date": 1725306877569,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n             \"ogte\": stats.iloc[1, 11]\n         }\n     elif type_ == \"APD\":\n         return {\n-            \"plan\": stats.iloc[2, 8],\n-            \"done\": stats.iloc[2, 9]\n+            \"plan\": stats.iloc[3, 15],\n+            \"done\": stats.iloc[3, 16]\n         }\n     else:\n         raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n \n"
        },
        {
          "date": 1725306883631,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n             \"ogte\": stats.iloc[1, 11]\n         }\n     elif type_ == \"APD\":\n         return {\n-            \"plan\": stats.iloc[3, 15],\n-            \"done\": stats.iloc[3, 16]\n+            \"plan\": stats.iloc[3, 14],\n+            \"done\": stats.iloc[3, 15]\n         }\n     else:\n         raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n \n"
        },
        {
          "date": 1725307918589,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,9 @@\n COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n STATS_KEY = os.environ[\"STATS_KEY\"]\n API_KEY = os.environ[\"API_KEY\"]\n \n+\n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url_template = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={{gid}}&format=csv'\n \n@@ -74,8 +75,27 @@\n # URL base para interagir com a API do Telegram\n base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n \n \n+\n+def change_title(current_title):\n+    # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n+    df_commands = fetch_commands()\n+    new_title = df_commands.iloc[2, 1]\n+\n+    if new_title != current_title:\n+        # Atualiza o título do grupo via API do Telegram\n+        parameters = {\n+            \"chat_id\": \"-4598989403\",\n+            \"title\": new_title\n+        }\n+        resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n+        resp.raise_for_status()\n+        print(f\"Título do grupo alterado para: {new_title}\")\n+        return new_title\n+    return current_title\n+\n+\n def read_msg(offset):\n     # Lê mensagens da API do Telegram a partir do offset fornecido\n     parameters = {\"offset\": offset}\n     resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n"
        },
        {
          "date": 1725307984734,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,4 +174,5 @@\n # Loop principal para ler mensagens continuamente\n offset = 0\n while True:\n     offset = read_msg(offset)\n+    current_title = change_title(current_title)\n"
        },
        {
          "date": 1725308027117,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,8 +93,9 @@\n         print(f\"Título do grupo alterado para: {new_title}\")\n         return new_title\n     return current_title\n \n+current_title = df_commands.iloc[2, 1]\n \n def read_msg(offset):\n     # Lê mensagens da API do Telegram a partir do offset fornecido\n     parameters = {\"offset\": offset}\n"
        },
        {
          "date": 1725308299394,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,19 +80,24 @@\n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n     new_title = df_commands.iloc[2, 1]\n-\n-    if new_title != current_title:\n-        # Atualiza o título do grupo via API do Telegram\n-        parameters = {\n-            \"chat_id\": \"-4598989403\",\n-            \"title\": new_title\n-        }\n-        resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n-        resp.raise_for_status()\n-        print(f\"Título do grupo alterado para: {new_title}\")\n-        return new_title\n+    \n+    # Verifica se o valor não é NaN e se é uma string válida\n+    if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n+        if new_title != current_title:\n+            # Atualiza o título do grupo via API do Telegram\n+            parameters = {\n+                \"chat_id\": \"<ID_DO_GRUPO>\",\n+                \"title\": new_title\n+            }\n+            resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n+            resp.raise_for_status()\n+            print(f\"Título do grupo alterado para: {new_title}\")\n+            return new_title\n+    else:\n+        print(\"Valor inválido para o título do grupo, mantendo o título atual.\")\n+    \n     return current_title\n \n current_title = df_commands.iloc[2, 1]\n \n"
        },
        {
          "date": 1725308332061,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[2, 1]\n+    new_title = df_commands.iloc[1, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308384509,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[1, 1]\n+    new_title = df_commands.iloc[3, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308643392,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n             # Atualiza o título do grupo via API do Telegram\n             parameters = {\n-                \"chat_id\": \"<ID_DO_GRUPO>\",\n+                \"chat_id\": \"-1002189305283\",\n                 \"title\": new_title\n             }\n             resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n             resp.raise_for_status()\n"
        },
        {
          "date": 1725308670878,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[3, 1]\n+    new_title = df_commands.iloc[1, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308690945,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[1, 1]\n+    new_title = df_commands.iloc[2, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308727227,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[2, 1]\n+    new_title = df_commands.iloc[2, 2]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308755649,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[2, 2]\n+    new_title = df_commands.iloc[2, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308802590,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[2, 1]\n+    new_title = df_commands.iloc[3, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725308807667,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,184 @@\n+import os\n+import io\n+import requests\n+import pandas as pd\n+from dotenv import load_dotenv\n+from keep_alive import keep_alive\n+\n+load_dotenv()\n+\n+# Mantém o bot ativo na web\n+keep_alive()\n+\n+# Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n+COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n+STATS_KEY = os.environ[\"STATS_KEY\"]\n+API_KEY = os.environ[\"API_KEY\"]\n+\n+\n+# URLs para acessar as planilhas do Google Sheets em formato CSV\n+commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n+stats_url_template = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={{gid}}&format=csv'\n+\n+\n+def fetch_csv(url):\n+    # Faz o download do arquivo CSV da URL fornecida\n+    response = requests.get(url, timeout=10)\n+    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n+    # Lê o conteúdo CSV em um DataFrame do pandas\n+    return pd.read_csv(io.StringIO(response.content.decode(\"utf-8\")))\n+\n+\n+def fetch_commands():\n+    # Obtém o DataFrame contendo os comandos\n+    return fetch_csv(commands_url)\n+\n+\n+def fetch_stats(gid, type_):\n+    # Obtém o DataFrame contendo as estatísticas da página especificada\n+    stats_url = stats_url_template.format(gid=gid)\n+    stats = fetch_csv(stats_url)\n+    \n+    if type_ == \"APL\":\n+        return {\n+            \"total\": stats.iloc[1, 5],\n+            \"igv\": stats.iloc[1, 6],\n+            \"ogv\": stats.iloc[1, 9],\n+            \"ogta\": stats.iloc[1, 10],\n+            \"ogte\": stats.iloc[1, 11]\n+        }\n+    elif type_ == \"APD\":\n+        return {\n+            \"plan\": stats.iloc[3, 14],\n+            \"done\": stats.iloc[3, 15]\n+        }\n+    else:\n+        raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n+\n+\n+# Obtém os dados iniciais das planilhas\n+df_commands = fetch_commands()\n+stats_apl = fetch_stats(1076143484, \"APL\")\n+stats_apd = fetch_stats(1226391324, \"APD\")\n+\n+# Combine os dados das duas páginas conforme necessário\n+combined_stats = {\n+    \"apl_total\": stats_apl[\"total\"],\n+    \"apl_igv\": stats_apl[\"igv\"],\n+    \"apl_ogv\": stats_apl[\"ogv\"],\n+    \"apl_ogta\": stats_apl[\"ogta\"],\n+    \"apl_ogte\": stats_apl[\"ogte\"],\n+    \"apd_plan\": stats_apd[\"plan\"],\n+    \"apd_done\": stats_apd[\"done\"]\n+}\n+\n+# URL base para interagir com a API do Telegram\n+base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n+\n+\n+\n+def change_title(current_title):\n+    # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n+    df_commands = fetch_commands()\n+    new_title = df_commands.iloc[3, 0]\n+    \n+    # Verifica se o valor não é NaN e se é uma string válida\n+    if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n+        if new_title != current_title:\n+            # Atualiza o título do grupo via API do Telegram\n+            parameters = {\n+                \"chat_id\": \"-1002189305283\",\n+                \"title\": new_title\n+            }\n+            resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n+            resp.raise_for_status()\n+            print(f\"Título do grupo alterado para: {new_title}\")\n+            return new_title\n+    else:\n+        print(\"Valor inválido para o título do grupo, mantendo o título atual.\")\n+    \n+    return current_title\n+\n+current_title = df_commands.iloc[2, 1]\n+\n+def read_msg(offset):\n+    # Lê mensagens da API do Telegram a partir do offset fornecido\n+    parameters = {\"offset\": offset}\n+    resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n+    resp.raise_for_status()\n+    data = resp.json()\n+\n+    # Envia cada mensagem recebida\n+    for result in data[\"result\"]:\n+        send_msg(result)\n+\n+    # Atualiza o offset para evitar processar mensagens duplicadas\n+    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n+\n+\n+def auto_answer(message):\n+    # Gera uma resposta automática para a mensagem recebida\n+    if not message.startswith(\"/\"):\n+        return None\n+\n+    # Remove o nome de usuário se presente\n+    message = message.split(\"@\")[0] if \"@\" in message else message\n+\n+    # Busca pela resposta correspondente ao comando\n+    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n+\n+    if not answer_row.empty:\n+        answer = answer_row.iloc[0][\"Answer\"]\n+        for key, value in combined_stats.items():\n+            answer = answer.replace(f\"{{{key}}}\", str(value))\n+        return answer\n+    else:\n+        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n+\n+\n+def send_msg(message):\n+    # Envia uma mensagem de volta ao usuário no Telegram\n+    try:\n+        if \"message\" in message:\n+            msg = message[\"message\"]\n+            if \"text\" in msg:\n+                text = msg[\"text\"]\n+                message_id = msg[\"message_id\"]\n+                chat_id = msg[\"chat\"][\"id\"]\n+                answer = auto_answer(text)  # Obtém a resposta automática\n+\n+                parameters = {\n+                    \"chat_id\": chat_id,\n+                    # Garante o encoding correto\n+                    \"text\": answer.encode(\"utf-8\").decode(\"utf-8\"),\n+                    \"reply_to_message_id\": message_id,\n+                }\n+                resp = requests.get(\n+                    f\"{base_url}/sendMessage\", params=parameters, timeout=10\n+                )\n+                resp.raise_for_status()\n+                print(\"Message received\")\n+            else:\n+                print(\"Mensagem with no text:\", msg)\n+        else:\n+            print(\"Mensagem not found:\", message)\n+    except requests.exceptions.Timeout:\n+        print(\"Timeout error occurred\")\n+    except requests.exceptions.ConnectionError:\n+        print(\"Connection error occurred\")\n+    except requests.exceptions.HTTPError as http_err:\n+        if resp.status_code == 400:\n+            print(\"Erro 400: Ignoring deleted message\")\n+        else:\n+            print(f\"HTTP error occurred: {http_err}\")\n+    except requests.exceptions.RequestException as req_err:\n+        print(f\"Request error occurred: {req_err}\")\n+    except Exception as err:\n+        print(f\"An unexpected error occurred: {err}\")\n+\n+\n+# Loop principal para ler mensagens continuamente\n+offset = 0\n+while True:\n+    offset = read_msg(offset)\n+    current_title = change_title(current_title)\n"
        },
        {
          "date": 1725308909479,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[3, 0]\n+    new_title = df_commands.iloc[1, -1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n@@ -181,188 +181,4 @@\n offset = 0\n while True:\n     offset = read_msg(offset)\n     current_title = change_title(current_title)\n-import os\n-import io\n-import requests\n-import pandas as pd\n-from dotenv import load_dotenv\n-from keep_alive import keep_alive\n-\n-load_dotenv()\n-\n-# Mantém o bot ativo na web\n-keep_alive()\n-\n-# Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n-COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n-STATS_KEY = os.environ[\"STATS_KEY\"]\n-API_KEY = os.environ[\"API_KEY\"]\n-\n-\n-# URLs para acessar as planilhas do Google Sheets em formato CSV\n-commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url_template = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={{gid}}&format=csv'\n-\n-\n-def fetch_csv(url):\n-    # Faz o download do arquivo CSV da URL fornecida\n-    response = requests.get(url, timeout=10)\n-    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n-    # Lê o conteúdo CSV em um DataFrame do pandas\n-    return pd.read_csv(io.StringIO(response.content.decode(\"utf-8\")))\n-\n-\n-def fetch_commands():\n-    # Obtém o DataFrame contendo os comandos\n-    return fetch_csv(commands_url)\n-\n-\n-def fetch_stats(gid, type_):\n-    # Obtém o DataFrame contendo as estatísticas da página especificada\n-    stats_url = stats_url_template.format(gid=gid)\n-    stats = fetch_csv(stats_url)\n-    \n-    if type_ == \"APL\":\n-        return {\n-            \"total\": stats.iloc[1, 5],\n-            \"igv\": stats.iloc[1, 6],\n-            \"ogv\": stats.iloc[1, 9],\n-            \"ogta\": stats.iloc[1, 10],\n-            \"ogte\": stats.iloc[1, 11]\n-        }\n-    elif type_ == \"APD\":\n-        return {\n-            \"plan\": stats.iloc[3, 14],\n-            \"done\": stats.iloc[3, 15]\n-        }\n-    else:\n-        raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n-\n-\n-# Obtém os dados iniciais das planilhas\n-df_commands = fetch_commands()\n-stats_apl = fetch_stats(1076143484, \"APL\")\n-stats_apd = fetch_stats(1226391324, \"APD\")\n-\n-# Combine os dados das duas páginas conforme necessário\n-combined_stats = {\n-    \"apl_total\": stats_apl[\"total\"],\n-    \"apl_igv\": stats_apl[\"igv\"],\n-    \"apl_ogv\": stats_apl[\"ogv\"],\n-    \"apl_ogta\": stats_apl[\"ogta\"],\n-    \"apl_ogte\": stats_apl[\"ogte\"],\n-    \"apd_plan\": stats_apd[\"plan\"],\n-    \"apd_done\": stats_apd[\"done\"]\n-}\n-\n-# URL base para interagir com a API do Telegram\n-base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n-\n-\n-\n-def change_title(current_title):\n-    # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n-    df_commands = fetch_commands()\n-    new_title = df_commands.iloc[3, 1]\n-    \n-    # Verifica se o valor não é NaN e se é uma string válida\n-    if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n-        if new_title != current_title:\n-            # Atualiza o título do grupo via API do Telegram\n-            parameters = {\n-                \"chat_id\": \"-1002189305283\",\n-                \"title\": new_title\n-            }\n-            resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n-            resp.raise_for_status()\n-            print(f\"Título do grupo alterado para: {new_title}\")\n-            return new_title\n-    else:\n-        print(\"Valor inválido para o título do grupo, mantendo o título atual.\")\n-    \n-    return current_title\n-\n-current_title = df_commands.iloc[2, 1]\n-\n-def read_msg(offset):\n-    # Lê mensagens da API do Telegram a partir do offset fornecido\n-    parameters = {\"offset\": offset}\n-    resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n-    resp.raise_for_status()\n-    data = resp.json()\n-\n-    # Envia cada mensagem recebida\n-    for result in data[\"result\"]:\n-        send_msg(result)\n-\n-    # Atualiza o offset para evitar processar mensagens duplicadas\n-    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n-\n-\n-def auto_answer(message):\n-    # Gera uma resposta automática para a mensagem recebida\n-    if not message.startswith(\"/\"):\n-        return None\n-\n-    # Remove o nome de usuário se presente\n-    message = message.split(\"@\")[0] if \"@\" in message else message\n-\n-    # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n-\n-    if not answer_row.empty:\n-        answer = answer_row.iloc[0][\"Answer\"]\n-        for key, value in combined_stats.items():\n-            answer = answer.replace(f\"{{{key}}}\", str(value))\n-        return answer\n-    else:\n-        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n-\n-\n-def send_msg(message):\n-    # Envia uma mensagem de volta ao usuário no Telegram\n-    try:\n-        if \"message\" in message:\n-            msg = message[\"message\"]\n-            if \"text\" in msg:\n-                text = msg[\"text\"]\n-                message_id = msg[\"message_id\"]\n-                chat_id = msg[\"chat\"][\"id\"]\n-                answer = auto_answer(text)  # Obtém a resposta automática\n-\n-                parameters = {\n-                    \"chat_id\": chat_id,\n-                    # Garante o encoding correto\n-                    \"text\": answer.encode(\"utf-8\").decode(\"utf-8\"),\n-                    \"reply_to_message_id\": message_id,\n-                }\n-                resp = requests.get(\n-                    f\"{base_url}/sendMessage\", params=parameters, timeout=10\n-                )\n-                resp.raise_for_status()\n-                print(\"Message received\")\n-            else:\n-                print(\"Mensagem with no text:\", msg)\n-        else:\n-            print(\"Mensagem not found:\", message)\n-    except requests.exceptions.Timeout:\n-        print(\"Timeout error occurred\")\n-    except requests.exceptions.ConnectionError:\n-        print(\"Connection error occurred\")\n-    except requests.exceptions.HTTPError as http_err:\n-        if resp.status_code == 400:\n-            print(\"Erro 400: Ignoring deleted message\")\n-        else:\n-            print(f\"HTTP error occurred: {http_err}\")\n-    except requests.exceptions.RequestException as req_err:\n-        print(f\"Request error occurred: {req_err}\")\n-    except Exception as err:\n-        print(f\"An unexpected error occurred: {err}\")\n-\n-\n-# Loop principal para ler mensagens continuamente\n-offset = 0\n-while True:\n-    offset = read_msg(offset)\n-    current_title = change_title(current_title)\n"
        },
        {
          "date": 1725308951332,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[1, -1]\n+    new_title = df_commands.iloc[0, 0]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         if new_title != current_title:\n"
        },
        {
          "date": 1725309428619,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,8 +71,14 @@\n     \"apd_plan\": stats_apd[\"plan\"],\n     \"apd_done\": stats_apd[\"done\"]\n }\n \n+def replace_placeholders(answer, stats):\n+    # Substitui os placeholders pelos valores correspondentes\n+    for key, value in stats.items():\n+        answer = answer.replace(f\"{{{key}}}\", str(value))\n+    return answer\n+\n # URL base para interagir com a API do Telegram\n base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n \n \n"
        },
        {
          "date": 1725309439548,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,10 @@\n # URLs para acessar as planilhas do Google Sheets em formato CSV\n commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n stats_url_template = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={{gid}}&format=csv'\n \n+# URL base para interagir com a API do Telegram\n+base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n \n def fetch_csv(url):\n     # Faz o download do arquivo CSV da URL fornecida\n     response = requests.get(url, timeout=10)\n@@ -77,13 +79,12 @@\n     for key, value in stats.items():\n         answer = answer.replace(f\"{{{key}}}\", str(value))\n     return answer\n \n-# URL base para interagir com a API do Telegram\n-base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n \n \n \n+\n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n     new_title = df_commands.iloc[0, 0]\n"
        },
        {
          "date": 1725309621290,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,8 +90,11 @@\n     new_title = df_commands.iloc[0, 0]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n+        # Substitui placeholders no novo título\n+        new_title = replace_placeholders(new_title, combined_stats)\n+        \n         if new_title != current_title:\n             # Atualiza o título do grupo via API do Telegram\n             parameters = {\n                 \"chat_id\": \"-1002189305283\",\n@@ -135,10 +138,9 @@\n     answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n-        for key, value in combined_stats.items():\n-            answer = answer.replace(f\"{{{key}}}\", str(value))\n+        return replace_placeholders(answer, combined_stats)\n         return answer\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n"
        },
        {
          "date": 1725309633022,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,9 +139,8 @@\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n-        return answer\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n \n"
        },
        {
          "date": 1725310392069,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,11 +80,11 @@\n         answer = answer.replace(f\"{{{key}}}\", str(value))\n     return answer\n \n \n+print(df_commands.head())\n \n \n-\n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n     new_title = df_commands.iloc[0, 0]\n"
        },
        {
          "date": 1725310571923,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,9 @@\n         answer = answer.replace(f\"{{{key}}}\", str(value))\n     return answer\n \n \n-print(df_commands.head())\n+print(df_commands.iloc[10:15])\n \n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n"
        },
        {
          "date": 1725310911320,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower()]\n+    answer_row = df_commands.loc(skiprows=10)[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311042909,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,12 +134,12 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc(skiprows=10)[df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n-        answer = answer_row.iloc[0][\"Answer\"]\n+        answer = answer_row.iloc[10][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n"
        },
        {
          "date": 1725311070344,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -137,9 +137,9 @@\n     # Busca pela resposta correspondente ao comando\n     answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n-        answer = answer_row.iloc[10][\"Answer\"]\n+        answer = answer_row.iloc[9][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n"
        },
        {
          "date": 1725311156744,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,12 +134,12 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.loc[df_commands[10,\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n-        answer = answer_row.iloc[9][\"Answer\"]\n+        answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n     else:\n         return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n \n"
        },
        {
          "date": 1725311191965,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,9 +125,9 @@\n     # Atualiza o offset para evitar processar mensagens duplicadas\n     return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n \n \n-def auto_answer(message):\n+async def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith(\"/\"):\n         return None\n \n"
        },
        {
          "date": 1725311412269,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc[df_commands[10,\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.iloc[9:].loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311429699,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.iloc[9:].loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.iloc[10:].loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311467505,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,9 +125,9 @@\n     # Atualiza o offset para evitar processar mensagens duplicadas\n     return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n \n \n-async def auto_answer(message):\n+def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith(\"/\"):\n         return None\n \n"
        },
        {
          "date": 1725311524477,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.iloc[10:].loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.iloc[9:].loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311567549,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.iloc[9:].loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.iloc[9:][df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311600142,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,11 +80,8 @@\n         answer = answer.replace(f\"{{{key}}}\", str(value))\n     return answer\n \n \n-print(df_commands.iloc[10:15])\n-\n-\n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n     new_title = df_commands.iloc[0, 0]\n"
        },
        {
          "date": 1725311607969,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,9 +131,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.iloc[9:][df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.iloc[8:][df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311628351,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,9 +131,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.iloc[8:][df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.iloc[10:][df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311687702,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,8 +80,11 @@\n         answer = answer.replace(f\"{{{key}}}\", str(value))\n     return answer\n \n \n+print(df_commands.iloc[10:15])\n+\n+\n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n     new_title = df_commands.iloc[0, 0]\n@@ -122,18 +125,18 @@\n     # Atualiza o offset para evitar processar mensagens duplicadas\n     return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n \n \n-def auto_answer(message):\n+async def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith(\"/\"):\n         return None\n \n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.iloc[10:][df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = .df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311702224,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0, 0]\n+    new_title = df_commands.iloc[0, 2]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725311767073,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,9 +134,9 @@\n     # Remove o nome de usuário se presente\n     message = message.split(\"@\")[0] if \"@\" in message else message\n \n     # Busca pela resposta correspondente ao comando\n-    answer_row = .df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n+    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n \n     if not answer_row.empty:\n         answer = answer_row.iloc[0][\"Answer\"]\n         return replace_placeholders(answer, combined_stats)\n"
        },
        {
          "date": 1725311796133,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,9 +125,9 @@\n     # Atualiza o offset para evitar processar mensagens duplicadas\n     return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n \n \n-async def auto_answer(message):\n+def auto_answer(message):\n     # Gera uma resposta automática para a mensagem recebida\n     if not message.startswith(\"/\"):\n         return None\n \n"
        },
        {
          "date": 1725311930503,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0, 2]\n+    new_title = df_commands.iloc[0, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725311978306,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0, 1]\n+    new_title = df_commands.iloc[1, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312036200,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[1, 1]\n+    new_title = df_commands.iloc[0, 0:1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312300151,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0, 0:1]\n+    new_title = df_commands.iloc[2, 0]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312342140,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[2, 0]\n+    new_title = df_commands.iloc[1, 1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312384868,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[1, 1]\n+    new_title = df_commands.iloc[0, 0:10]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312439608,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0, 0:10]\n+    new_title = df_commands.iloc[\"Título Grupo\"]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312466965,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[\"Título Grupo\"]\n+    new_title = df_commands.iloc[\"Title\"]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312472597,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[\"Title\"]\n+    new_title = df_commands.loc[\"Title\"]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312510297,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.loc[\"Title\"]\n+    new_title = df_commands.iloc[0:1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312538730,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,9 @@\n         answer = answer.replace(f\"{{{key}}}\", str(value))\n     return answer\n \n \n-print(df_commands.iloc[10:15])\n+print(df_commands.iloc)\n \n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n"
        },
        {
          "date": 1725312563194,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0:1]\n+    new_title = df_commands.iloc[-1]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312697930,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[-1]\n+    new_title = df_commands.iloc[0,3]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312732826,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n \n def change_title(current_title):\n     # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n     df_commands = fetch_commands()\n-    new_title = df_commands.iloc[0,3]\n+    new_title = df_commands.iloc[0,2]\n     \n     # Verifica se o valor não é NaN e se é uma string válida\n     if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n         # Substitui placeholders no novo título\n"
        },
        {
          "date": 1725312753236,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,189 @@\n+import os\n+import io\n+import requests\n+import pandas as pd\n+from dotenv import load_dotenv\n+from keep_alive import keep_alive\n+\n+load_dotenv()\n+\n+# Mantém o bot ativo na web\n+keep_alive()\n+\n+# Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n+COMMANDS_KEY = os.environ[\"COMMANDS_KEY\"]\n+STATS_KEY = os.environ[\"STATS_KEY\"]\n+API_KEY = os.environ[\"API_KEY\"]\n+\n+\n+# URLs para acessar as planilhas do Google Sheets em formato CSV\n+commands_url = f'https://docs.google.com/spreadsheets/d/{COMMANDS_KEY}/export?gid=0&format=csv'\n+stats_url_template = f'https://docs.google.com/spreadsheets/d/{STATS_KEY}/export?gid={{gid}}&format=csv'\n+\n+# URL base para interagir com a API do Telegram\n+base_url = f\"https://api.telegram.org/bot{API_KEY}\"\n+\n+def fetch_csv(url):\n+    # Faz o download do arquivo CSV da URL fornecida\n+    response = requests.get(url, timeout=10)\n+    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n+    # Lê o conteúdo CSV em um DataFrame do pandas\n+    return pd.read_csv(io.StringIO(response.content.decode(\"utf-8\")))\n+\n+\n+def fetch_commands():\n+    # Obtém o DataFrame contendo os comandos\n+    return fetch_csv(commands_url)\n+\n+\n+def fetch_stats(gid, type_):\n+    # Obtém o DataFrame contendo as estatísticas da página especificada\n+    stats_url = stats_url_template.format(gid=gid)\n+    stats = fetch_csv(stats_url)\n+    \n+    if type_ == \"APL\":\n+        return {\n+            \"total\": stats.iloc[1, 5],\n+            \"igv\": stats.iloc[1, 6],\n+            \"ogv\": stats.iloc[1, 9],\n+            \"ogta\": stats.iloc[1, 10],\n+            \"ogte\": stats.iloc[1, 11]\n+        }\n+    elif type_ == \"APD\":\n+        return {\n+            \"plan\": stats.iloc[3, 14],\n+            \"done\": stats.iloc[3, 15]\n+        }\n+    else:\n+        raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n+\n+\n+# Obtém os dados iniciais das planilhas\n+df_commands = fetch_commands()\n+stats_apl = fetch_stats(1076143484, \"APL\")\n+stats_apd = fetch_stats(1226391324, \"APD\")\n+\n+# Combine os dados das duas páginas conforme necessário\n+combined_stats = {\n+    \"apl_total\": stats_apl[\"total\"],\n+    \"apl_igv\": stats_apl[\"igv\"],\n+    \"apl_ogv\": stats_apl[\"ogv\"],\n+    \"apl_ogta\": stats_apl[\"ogta\"],\n+    \"apl_ogte\": stats_apl[\"ogte\"],\n+    \"apd_plan\": stats_apd[\"plan\"],\n+    \"apd_done\": stats_apd[\"done\"]\n+}\n+\n+def replace_placeholders(answer, stats):\n+    # Substitui os placeholders pelos valores correspondentes\n+    for key, value in stats.items():\n+        answer = answer.replace(f\"{{{key}}}\", str(value))\n+    return answer\n+\n+\n+def change_title(current_title):\n+    # Função para verificar o valor da célula específica e mudar o título do grupo se necessário\n+    df_commands = fetch_commands()\n+    new_title = df_commands.iloc[0,2]\n+    \n+    # Verifica se o valor não é NaN e se é uma string válida\n+    if pd.notna(new_title) and isinstance(new_title, str) and new_title.strip():\n+        # Substitui placeholders no novo título\n+        new_title = replace_placeholders(new_title, combined_stats)\n+        \n+        if new_title != current_title:\n+            # Atualiza o título do grupo via API do Telegram\n+            parameters = {\n+                \"chat_id\": \"-1002189305283\",\n+                \"title\": new_title\n+            }\n+            resp = requests.get(f\"{base_url}/setChatTitle\", params=parameters, timeout=10)\n+            resp.raise_for_status()\n+            print(f\"Título do grupo alterado para: {new_title}\")\n+            return new_title\n+    else:\n+        print(\"Valor inválido para o título do grupo, mantendo o título atual.\")\n+    \n+    return current_title\n+\n+current_title = df_commands.iloc[2, 1]\n+\n+def read_msg(offset):\n+    # Lê mensagens da API do Telegram a partir do offset fornecido\n+    parameters = {\"offset\": offset}\n+    resp = requests.get(f\"{base_url}/getUpdates\", params=parameters, timeout=10)\n+    resp.raise_for_status()\n+    data = resp.json()\n+\n+    # Envia cada mensagem recebida\n+    for result in data[\"result\"]:\n+        send_msg(result)\n+\n+    # Atualiza o offset para evitar processar mensagens duplicadas\n+    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n+\n+\n+def auto_answer(message):\n+    # Gera uma resposta automática para a mensagem recebida\n+    if not message.startswith(\"/\"):\n+        return None\n+\n+    # Remove o nome de usuário se presente\n+    message = message.split(\"@\")[0] if \"@\" in message else message\n+\n+    # Busca pela resposta correspondente ao comando\n+    answer_row = df_commands.loc[df_commands[\"Question\"].str.lower() == message.lower(),]\n+\n+    if not answer_row.empty:\n+        answer = answer_row.iloc[0][\"Answer\"]\n+        return replace_placeholders(answer, combined_stats)\n+    else:\n+        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n+\n+\n+def send_msg(message):\n+    # Envia uma mensagem de volta ao usuário no Telegram\n+    try:\n+        if \"message\" in message:\n+            msg = message[\"message\"]\n+            if \"text\" in msg:\n+                text = msg[\"text\"]\n+                message_id = msg[\"message_id\"]\n+                chat_id = msg[\"chat\"][\"id\"]\n+                answer = auto_answer(text)  # Obtém a resposta automática\n+\n+                parameters = {\n+                    \"chat_id\": chat_id,\n+                    # Garante o encoding correto\n+                    \"text\": answer.encode(\"utf-8\").decode(\"utf-8\"),\n+                    \"reply_to_message_id\": message_id,\n+                }\n+                resp = requests.get(\n+                    f\"{base_url}/sendMessage\", params=parameters, timeout=10\n+                )\n+                resp.raise_for_status()\n+                print(\"Message received\")\n+            else:\n+                print(\"Mensagem with no text:\", msg)\n+        else:\n+            print(\"Mensagem not found:\", message)\n+    except requests.exceptions.Timeout:\n+        print(\"Timeout error occurred\")\n+    except requests.exceptions.ConnectionError:\n+        print(\"Connection error occurred\")\n+    except requests.exceptions.HTTPError as http_err:\n+        if resp.status_code == 400:\n+            print(\"Erro 400: Ignoring deleted message\")\n+        else:\n+            print(f\"HTTP error occurred: {http_err}\")\n+    except requests.exceptions.RequestException as req_err:\n+        print(f\"Request error occurred: {req_err}\")\n+    except Exception as err:\n+        print(f\"An unexpected error occurred: {err}\")\n+\n+\n+# Loop principal para ler mensagens continuamente\n+offset = 0\n+while True:\n+    offset = read_msg(offset)\n+    current_title = change_title(current_title)\n"
        },
        {
          "date": 1725423410142,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,13 @@\n         return {\n             \"plan\": stats.iloc[3, 14],\n             \"done\": stats.iloc[3, 15]\n         }\n+    elif type_ == \"OPEN\":\n+        return {\n+            \"plan\": stats.iloc[11, 2],\n+            \"done\": stats.iloc[11, 3]\n+        }\n     else:\n         raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n \n \n"
        },
        {
          "date": 1725423574644,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,15 +58,16 @@\n         return {\"plan\": stats.iloc[3, 14], \"done\": stats.iloc[3, 15]}\n     elif type_ == \"OPEN\":\n         return {\"plan\": stats.iloc[11, 2], \"done\": stats.iloc[11, 3]}\n     else:\n-        raise ValueError(\"Invalid type specified. Use 'APL' or 'APD'.\")\n+        return EOFError\n \n \n # Obtém os dados iniciais das planilhas\n df_commands = fetch_commands()\n stats_apl = fetch_stats(1076143484, \"APL\")\n stats_apd = fetch_stats(1226391324, \"APD\")\n+stats_open = fetch_stats(1226391324, \"OPEN\")\n \n # Combine os dados das duas páginas conforme necessário\n combined_stats = {\n     \"apl_total\": stats_apl[\"total\"],\n@@ -75,8 +76,10 @@\n     \"apl_ogta\": stats_apl[\"ogta\"],\n     \"apl_ogte\": stats_apl[\"ogte\"],\n     \"apd_plan\": stats_apd[\"plan\"],\n     \"apd_done\": stats_apd[\"done\"],\n+    \"open_plan\": stats_open[\"plan\"],\n+    \"open_done\": stats_open[\"done\"],    \n }\n \n \n def replace_placeholders(answer, stats):\n"
        },
        {
          "date": 1725423618322,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n         return {\"plan\": stats.iloc[3, 14], \"done\": stats.iloc[3, 15]}\n     elif type_ == \"OPEN\":\n         return {\"plan\": stats.iloc[11, 2], \"done\": stats.iloc[11, 3]}\n     else:\n-        return EOFError\n+        return Exception\n \n \n # Obtém os dados iniciais das planilhas\n df_commands = fetch_commands()\n"
        }
      ],
      "date": 1725165410976,
      "name": "Commit-0",
      "content": "import os\nimport requests\nimport pandas as pd\nimport io\nfrom keep_alive import keep_alive\n\n# Mantém o bot ativo na web\nkeep_alive()\n\n# Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\nCOMMANDS_KEY = os.environ['COMMANDS_KEY']\nSTATS_KEY = os.environ['STATS_KEY']\nAPI_KEY = os.environ['API_KEY']\n\n# URLs para acessar as planilhas do Google Sheets em formato CSV\ncommands_url = f'https: //docs.google.com/spreadsheets/d/{\n    COMMANDS_KEY}/export?gid=0&format=csv'\nstats_url = f'https: //docs.google.com/spreadsheets/d/{\n    STATS_KEY}/export?gid=1076143484&format=csv'\n\n\ndef fetch_csv(url):\n    # Faz o download do arquivo CSV da URL fornecida\n    response = requests.get(url)\n    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n    # Lê o conteúdo CSV em um DataFrame do pandas\n    return pd.read_csv(io.StringIO(response.content.decode('utf-8')))\n\n\ndef fetch_commands():\n    # Obtém o DataFrame contendo os comandos\n    return fetch_csv(commands_url)\n\n\ndef fetch_stats():\n    # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n    stats = fetch_csv(stats_url)\n    return {\n        'apl_total': stats.iloc[1, 5],\n        'apl_igv': stats.iloc[1, 6],\n        'apl_ogv': stats.iloc[1, 9],\n        'apl_ogta': stats.iloc[1, 10],\n        'apl_ogte': stats.iloc[1, 11]\n    }\n\n\n# Obtém os dados iniciais das planilhas\ndf_commands = fetch_commands()\nstats = fetch_stats()\n\n# URL base para interagir com a API do Telegram\nbase_url = f'https: //api.telegram.org/bot{API_KEY}'\n\n\ndef read_msg(offset):\n    # Lê mensagens da API do Telegram a partir do offset fornecido\n    parameters = {\"offset\": offset}\n    resp = requests.get(f'{base_url}/getUpdates', params=parameters)\n    resp.raise_for_status()\n    data = resp.json()\n\n    # Envia cada mensagem recebida\n    for result in data[\"result\"]:\n        send_msg(result)\n\n    # Atualiza o offset para evitar processar mensagens duplicadas\n    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n\n\ndef auto_answer(message):\n    # Gera uma resposta automática para a mensagem recebida\n    if not message.startswith('/'):\n        return None\n\n    # Remove o nome de usuário se presente\n    message = message.split('@')[0] if '@' in message else message\n\n    # Busca pela resposta correspondente ao comando\n    answer_row = df_commands.loc[df_commands['Question'].str.lower(\n    ) == message.lower()]\n\n    if not answer_row.empty:\n        answer = answer_row.iloc[0]['Answer']\n        for key, value in stats.items():\n            answer = answer.replace(f'{{{key}}}', value)\n        return answer\n    else:\n        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n\n\ndef send_msg(message):\n    # Envia uma mensagem de volta ao usuário no Telegram\n    try:\n        if \"message\" in message:\n            msg = message[\"message\"]\n            if \"text\" in msg:\n                text = msg[\"text\"]\n                message_id = msg[\"message_id\"]\n                chat_id = msg[\"chat\"][\"id\"]\n                answer = auto_answer(text)  # Obtém a resposta automática\n\n                parameters = {\n                    \"chat_id\": chat_id,\n                    # Garante o encoding correto\n                    \"text\": answer.encode('utf-8').decode('utf-8'),\n                    \"reply_to_message_id\": message_id\n                }\n                resp = requests.get(\n                    f'{base_url}/sendMessage', params=parameters)\n                resp.raise_for_status()\n                print(resp.text)\n            else:\n                print(\"Mensagem sem texto:\", msg)\n        else:\n            print(\"Mensagem não encontrada:\", message)\n    except requests.exceptions.HTTPError as http_err:\n        if resp.status_code == 400:\n            print(\"Erro 400: Ignorando mensagem excluída\")\n        else:\n            print(f\"HTTP error occurred: {http_err}\")\n    except Exception as err:\n        print(f\"Other error occurred: {err}\")\n\n\n# Loop principal para ler mensagens continuamente\noffset = 0\nwhile True:\n    offset = read_msg(offset)\n"
    }
  ]
}



