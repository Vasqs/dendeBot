{
    "sourceFile": "keep_alive.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1725166576862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725166600712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-from flask import Flask, render_template\n+from flask import Flask\n from threading import Thread\n app = Flask(__name__)\n \n \n"
                },
                {
                    "date": 1725166949996,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-from flask import Flask\n+from flask import Flask, render_template\n from threading import Thread\n app = Flask(__name__)\n \n \n"
                },
                {
                    "date": 1725167544873,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,17 +1,128 @@\n-from flask import Flask, render_template\n-from threading import Thread\n-app = Flask(__name__)\n+import os\n+import requests\n+import pandas as pd\n+import io\n+from keep_alive import keep_alive\n \n+# Mantém o bot ativo na web\n+keep_alive()\n \n-@app.route('/')\n-def index():\n-    return \"Alive\"\n+# Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n+COMMANDS_KEY = os.environ['COMMANDS_KEY']\n+STATS_KEY = os.environ['STATS_KEY']\n+API_KEY = os.environ['API_KEY']\n \n+# URLs para acessar as planilhas do Google Sheets em formato CSV\n+commands_url = f'https://docs.google.com/spreadsheets/d/{\n+    COMMANDS_KEY}/export?gid=0&format=csv'\n+stats_url = f'https://docs.google.com/spreadsheets/d/{\n+    STATS_KEY}/export?gid=1076143484&format=csv'\n \n-def run():\n-    app.run(host='0.0.0.0', port=8080)\n \n+def fetch_csv(url):\n+    # Faz o download do arquivo CSV da URL fornecida\n+    response = requests.get(url)\n+    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n+    # Lê o conteúdo CSV em um DataFrame do pandas\n+    return pd.read_csv(io.StringIO(response.content.decode('utf-8')))\n \n-def keep_alive():\n-    t = Thread(target=run)\n-    t.start()\n+\n+def fetch_commands():\n+    # Obtém o DataFrame contendo os comandos\n+    return fetch_csv(commands_url)\n+\n+\n+def fetch_stats():\n+    # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n+    stats = fetch_csv(stats_url)\n+    return {\n+        'apl_total': stats.iloc[1, 5],\n+        'apl_igv': stats.iloc[1, 6],\n+        'apl_ogv': stats.iloc[1, 9],\n+        'apl_ogta': stats.iloc[1, 10],\n+        'apl_ogte': stats.iloc[1, 11]\n+    }\n+\n+\n+# Obtém os dados iniciais das planilhas\n+df_commands = fetch_commands()\n+stats = fetch_stats()\n+\n+# URL base para interagir com a API do Telegram\n+base_url = f'https://api.telegram.org/bot{API_KEY}'\n+\n+\n+def read_msg(offset):\n+    # Lê mensagens da API do Telegram a partir do offset fornecido\n+    parameters = {\"offset\": offset}\n+    resp = requests.get(f'{base_url}/getUpdates', params=parameters)\n+    resp.raise_for_status()\n+    data = resp.json()\n+\n+    # Envia cada mensagem recebida\n+    for result in data[\"result\"]:\n+        send_msg(result)\n+\n+    # Atualiza o offset para evitar processar mensagens duplicadas\n+    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n+\n+\n+def auto_answer(message):\n+    # Gera uma resposta automática para a mensagem recebida\n+    if not message.startswith('/'):\n+        return None\n+\n+    # Remove o nome de usuário se presente\n+    message = message.split('@')[0] if '@' in message else message\n+\n+    # Busca pela resposta correspondente ao comando\n+    answer_row = df_commands.loc[df_commands['Question'].str.lower(\n+    ) == message.lower()]\n+\n+    if not answer_row.empty:\n+        answer = answer_row.iloc[0]['Answer']\n+        for key, value in stats.items():\n+            answer = answer.replace(f'{{{key}}}', value)\n+        return answer\n+    else:\n+        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n+\n+\n+def send_msg(message):\n+    # Envia uma mensagem de volta ao usuário no Telegram\n+    try:\n+        if \"message\" in message:\n+            msg = message[\"message\"]\n+            if \"text\" in msg:\n+                text = msg[\"text\"]\n+                message_id = msg[\"message_id\"]\n+                chat_id = msg[\"chat\"][\"id\"]\n+                answer = auto_answer(text)  # Obtém a resposta automática\n+\n+                parameters = {\n+                    \"chat_id\": chat_id,\n+                    # Garante o encoding correto\n+                    \"text\": answer.encode('utf-8').decode('utf-8'),\n+                    \"reply_to_message_id\": message_id\n+                }\n+                resp = requests.get(\n+                    f'{base_url}/sendMessage', params=parameters)\n+                resp.raise_for_status()\n+                print(resp.text)\n+            else:\n+                print(\"Mensagem sem texto:\", msg)\n+        else:\n+            print(\"Mensagem não encontrada:\", message)\n+    except requests.exceptions.HTTPError as http_err:\n+        if resp.status_code == 400:\n+            print(\"Erro 400: Ignorando mensagem excluída\")\n+        else:\n+            print(f\"HTTP error occurred: {http_err}\")\n+    except Exception as err:\n+        print(f\"Other error occurred: {err}\")\n+\n+\n+# Loop principal para ler mensagens continuamente\n+offset = 0\n+while True:\n+    offset = read_msg(offset)\n"
                },
                {
                    "date": 1725167562244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,128 +1,17 @@\n-import os\n-import requests\n-import pandas as pd\n-import io\n-from keep_alive import keep_alive\n+from flask import Flask, render_template\n+from threading import Thread\n+app = Flask(__name__)\n \n-# Mantém o bot ativo na web\n-keep_alive()\n \n-# Obtém chaves de ambiente para acessar as planilhas e a API do Telegram\n-COMMANDS_KEY = os.environ['COMMANDS_KEY']\n-STATS_KEY = os.environ['STATS_KEY']\n-API_KEY = os.environ['API_KEY']\n+@app.route('/')\n+def index():\n+    return \"Alive\"\n \n-# URLs para acessar as planilhas do Google Sheets em formato CSV\n-commands_url = f'https://docs.google.com/spreadsheets/d/{\n-    COMMANDS_KEY}/export?gid=0&format=csv'\n-stats_url = f'https://docs.google.com/spreadsheets/d/{\n-    STATS_KEY}/export?gid=1076143484&format=csv'\n \n+def run():\n+    app.run(host='0.0.0.0', port=8080)\n \n-def fetch_csv(url):\n-    # Faz o download do arquivo CSV da URL fornecida\n-    response = requests.get(url)\n-    response.raise_for_status()  # Garante que a solicitação foi bem-sucedida\n-    # Lê o conteúdo CSV em um DataFrame do pandas\n-    return pd.read_csv(io.StringIO(response.content.decode('utf-8')))\n \n-\n-def fetch_commands():\n-    # Obtém o DataFrame contendo os comandos\n-    return fetch_csv(commands_url)\n-\n-\n-def fetch_stats():\n-    # Obtém o DataFrame contendo as estatísticas e retorna um dicionário com valores específicos\n-    stats = fetch_csv(stats_url)\n-    return {\n-        'apl_total': stats.iloc[1, 5],\n-        'apl_igv': stats.iloc[1, 6],\n-        'apl_ogv': stats.iloc[1, 9],\n-        'apl_ogta': stats.iloc[1, 10],\n-        'apl_ogte': stats.iloc[1, 11]\n-    }\n-\n-\n-# Obtém os dados iniciais das planilhas\n-df_commands = fetch_commands()\n-stats = fetch_stats()\n-\n-# URL base para interagir com a API do Telegram\n-base_url = f'https://api.telegram.org/bot{API_KEY}'\n-\n-\n-def read_msg(offset):\n-    # Lê mensagens da API do Telegram a partir do offset fornecido\n-    parameters = {\"offset\": offset}\n-    resp = requests.get(f'{base_url}/getUpdates', params=parameters)\n-    resp.raise_for_status()\n-    data = resp.json()\n-\n-    # Envia cada mensagem recebida\n-    for result in data[\"result\"]:\n-        send_msg(result)\n-\n-    # Atualiza o offset para evitar processar mensagens duplicadas\n-    return data[\"result\"][-1][\"update_id\"] + 1 if data[\"result\"] else offset\n-\n-\n-def auto_answer(message):\n-    # Gera uma resposta automática para a mensagem recebida\n-    if not message.startswith('/'):\n-        return None\n-\n-    # Remove o nome de usuário se presente\n-    message = message.split('@')[0] if '@' in message else message\n-\n-    # Busca pela resposta correspondente ao comando\n-    answer_row = df_commands.loc[df_commands['Question'].str.lower(\n-    ) == message.lower()]\n-\n-    if not answer_row.empty:\n-        answer = answer_row.iloc[0]['Answer']\n-        for key, value in stats.items():\n-            answer = answer.replace(f'{{{key}}}', value)\n-        return answer\n-    else:\n-        return \"Não sei esse comando não pvt, manda Ananda me programar melhor aê\"\n-\n-\n-def send_msg(message):\n-    # Envia uma mensagem de volta ao usuário no Telegram\n-    try:\n-        if \"message\" in message:\n-            msg = message[\"message\"]\n-            if \"text\" in msg:\n-                text = msg[\"text\"]\n-                message_id = msg[\"message_id\"]\n-                chat_id = msg[\"chat\"][\"id\"]\n-                answer = auto_answer(text)  # Obtém a resposta automática\n-\n-                parameters = {\n-                    \"chat_id\": chat_id,\n-                    # Garante o encoding correto\n-                    \"text\": answer.encode('utf-8').decode('utf-8'),\n-                    \"reply_to_message_id\": message_id\n-                }\n-                resp = requests.get(\n-                    f'{base_url}/sendMessage', params=parameters)\n-                resp.raise_for_status()\n-                print(resp.text)\n-            else:\n-                print(\"Mensagem sem texto:\", msg)\n-        else:\n-            print(\"Mensagem não encontrada:\", message)\n-    except requests.exceptions.HTTPError as http_err:\n-        if resp.status_code == 400:\n-            print(\"Erro 400: Ignorando mensagem excluída\")\n-        else:\n-            print(f\"HTTP error occurred: {http_err}\")\n-    except Exception as err:\n-        print(f\"Other error occurred: {err}\")\n-\n-\n-# Loop principal para ler mensagens continuamente\n-offset = 0\n-while True:\n-    offset = read_msg(offset)\n+def keep_alive():\n+    t = Thread(target=run)\n+    t.start()\n"
                }
            ],
            "date": 1725166576862,
            "name": "Commit-0",
            "content": "from flask import Flask, render_template\nfrom threading import Thread\napp = Flask(__name__)\n\n\n@app.route('/')\ndef index():\n    return \"Alive\"\n\n\ndef run():\n    app.run(host='0.0.0.0', port=8080)\n\n\ndef keep_alive():\n    t = Thread(target=run)\n    t.start()\n"
        }
    ]
}